Instructions

Registers (all 8 bytes in size):
- r0
- r1
- r2
- r3
- cmp


Primitive Types:
Bool (8 byte)
Int (64 bit signed)
Float (64 bit IEEE 754)
String (Pointer to shared immutable reference)
Array (Pointer to array metadata and inline data)
Map (Pointer to hashmap metadata and inline buckets)
Set (Pointer to hashset metadata and inline buckets)
Vector (Pointer to 24 byte, 3 component Float vector)

Arguments:
Arguments are stored in registers 

Bytecode:
All bytecodes are in one of 3 patterns, where I is the 1 byte instructions
I A B C		A = 1 byte operand, B = 1 byte operand, C = 1 byte operand
I A B		A = 1 byte operand, B = 2 byte operand
I A			A = 3 byte operand

== Basic ==
[0x00] nop
[0x01] halt
[0x02] mov <dst, src>(I A B) Copy value at register src to register dst
[0x03] load <dst, src>(I A B) Copy value at the address held at src register into dst register
[0x04] loadi <dst, immediate>(I A B)  Copy immediate value into dst register
[0x05] loadc <dst, const>(I A B) Copy constant value at index const into dst register
[0x06] store <dst, src>(I A B) Copy value at register src into the address held at dst register
[0x07] push <src>(I A) Push value at src register to the top of the stack
[0x08] pop <dst>(I A) Pop the value at the top of the register into dst register
[0x09] jmp <dst>(I A) Unconditional jump to the bytecode held at dst register
[0x10] jz <dst>(I A) Jump to the bytecode held at dst register if cmp register is 0
[0x11] jnz <dst>(I A) Jump to the bytecode held at dst register if cmp register is not 0
[0x12] ret // idk


== Comparison ==
iseq(arg1, arg2)		[] Int/Bool equality comparison. Stores result in register F
isne(arg1, arg2)		[] Int/Bool inequality comparison. Stores result in register F
islt(arg1, arg2)		[] Int/Bool less than comparison. Stores 1 in register F if arg1 is less than arg2, otherwise stores 0
isgt(arg1, arg2)		[] Int/Bool greater than comparison. Stores 1 in register F if arg1 is greater than arg2, otherwise stores 0
isle(arg1, arg2)		[] Int/Bool less than or equal to comparison. Stores 1 in register F if arg1 is less than or equal to arg2, otherwise stores 0
isge(arg1, arg2)		[] Int/Bool greater than or equal to comparison. Stores 1 in register F if arg1 is greater than or equal to arg2, otherwise stores 0
fiseq(arg1, arg2)		[]
fisne(arg1, arg2)		[]
fislt(arg1, arg2)		[]
fisgt(arg1, arg2)		[]
fisle(arg1, arg2)		[]
fisge(arg1, arg2)		[]
siseq(arg1, arg2)		[]
sisne(arg1, arg2)		[]
sislt(arg1, arg2)		[]
sisgt(arg1, arg2)		[]
sisle(arg1, arg2)		[]
sisge(arg1, arg2)		[]
aiseq(arg1, arg2)		[]
aisne(arg1, arg2)		[]
viseq(arg1, arg2)		[]
visne(arg1, arg2)		[]

== Bool ==
btos(dst, arg1)			[]
btoi(dst, arg1)			[]
btof(dst, arg1)			[]

== Integer ==
iadd(dst, arg1, arg2)	[]
isub(dst, arg1, arg2)	[]
imul(dst, arg1, arg2)	[]
idiv(dst, arg1, arg2)	[]
imod(dst, arg1, arg2)	[]
ipow(dst, arg1, arg2)	[]
not(dst, arg1, arg2)	[]
and(dst, arg1, arg2)	[]
or(dst, arg1, arg2)		[]
lsh(dst, arg1, arg2)	[]
rsh(dst, arg1, arg2)	[]
itof(dst, arg1)			[]
itos(dst, arg1)			[]
itob(dst, arg1)			[]

== Float ==
fadd(dst, arg1, arg2)	[]
fsub(dst, arg1, arg2)	[]
fmul(dst, arg1, arg2)	[]
fdiv(dst, arg1, arg2)	[]
fmod(dst, arg1, arg2)	[]
fpow(dst, arg1, arg2)	[]
sqrt(dst, arg1, arg2)	[]
sin(dst, arg1)			[]
cos(dst, arg1)			[]
tan(dst, arg1)			[]
ftoi(dst, arg1)			[]
ftos(dst, arg1)			[]
ftob(dst, arg1)			[]

== String ==
slen(dst, arg1) 		[]
scc(dst, arg1, arg2)	[]
sfind(dst, arg1)		[]
ssub(dst, arg1, arg2)	[]
sformat(dst, args...)	[]
print(arg1)				[]
stob(dst, arg1)			[]
stoi(dst, arg1)			[]
stof(dst, arg1)			[]
sdrop(arg1)				[]

== Array ==
alen(dst, arg1)			[]
aget(dst, arg1)			[]
aset(dst, arg1, arg2)	[]
aadd(arg1, arg2)		[]
afind(arg1)				[]
arem(dst, arg1)			[]
ains(arg1, arg2)		[]
atoset(dst, arg1)		[]
adrop(arg1)				[]

== Map ==
mlen(dst, arg1)			[]
mget(dst, arg1)			[]
mins(dst, arg1, arg2)	[]
mfind(dst, arg1)		[]
mrem(dst, arg1)			[]
mdrop(arg1)				[]

== Set ==
setlen(dst, arg1)		[]
setget(dst, arg1)		[]
setins(dst, arg1)		[]
setcont(dst, arg1)		[]
setrem(dst, arg1)		[]
settoa(dst, arg1)		[]
setdrop(arg1)			[]

== Vector ==
vadd(dst, arg1, arg2)	[]
vadds(dst, arg1, arg2)	[]
vsub(dst, arg1, arg2)	[]
vsubs(dst, arg1, arg2)	[]
vmul(dst, arg1, arg2)	[]
vmuls(dst, arg1, arg2)	[]
vdiv(dst, arg1, arg2)	[]
vdivs(dst, arg1, arg2)	[]
vdot(dst, arg1, arg2)	[]
vcross(dst, arg1, arg2)	[]
vdrop(arg1)				[]


